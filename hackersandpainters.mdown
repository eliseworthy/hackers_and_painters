Hackers and Painters
====================

Questions:
----------  

1. Summarize the chapter (1+ bullets)
2. What was one idea the surprised or stood out to you? Why? (2-4 sentences)
3. What was a question that you saw as unanswered? (1-2 sentences)
4. Did you have any objections or disagreements? (1-2 sentences)
5. What were your key take aways or things you want to remember? (1+ bullets)  

1
-

1.  
US public schools are holding pens for adolesents that breed boredom and cruelty.  
Nerds aren't popular because they have better things to do.  

2. 
The idea that high school students have an elaborate caste system is surprising. The author seemed to think that popularity was both caused by being complacent and by actively working toward being popular. These conflicting ideas weren't resolved.

3. 
The author made broad claims about high school students' caste systems, popular students' disinterest in learning, the lack of involvement by adults in adolelecents' lives, and the uselessness of high school. Do other types of learning environments exist? He never tries to disprove his own personal experience.

4. 
His idea that student popularity is caused by caring more about popularity than about other things, and that popularity is based on a certain set of criteria, seems flawed. Thankfully, my high school experience was awesome. I felt neither popular nor unpopular and the adults in my life were actively engaged in seeing me succeed, academically and beyond.

5. 
Some nerds were bullied heavily in school and didn't find productive things to do. 

2
-  

1.  
Hackers are more like painters (makers) than engineers (implementers).
There is nuance and art to writing software.  

2. 
The author said to "...fight design wars in new markets," after explaining why large companies create bad software. This is surprising. It seems as if there's a tremendous amount to be gained by creating beautiful software that replaces existing crappy software written by large teams.

3. 
Why is knowing theory irrelevant? I understand that practice and application are extremely important to writing code, but it seems that knowing how systems are implemented to be efficient, and knowing about coding practices, is also valuable.

4. 
The author said that contribution to open source was paramount in hiring - that it proved that candidates loved their craft. I've heard arguments against this, particularly related to diversity and championing women who care for families and take on a larger number of domestic duties than men. I think contribution to open source is not the primary identifier of love of software and that idea should be revamped.

5. 
Hackers start original, and get good, while scientists start good and get original. 
Hacking, like painting, is done through gradual refinement. 
Empathy for the user is crucial in creating great software. 

3
-

1.  
Moral fashion should be considered and consciously avoided.

2. 
Opinions about morality are binary - you can ask whether something's true. Heretics think that common ideas are false. I believe that all moral issues are relative, so thinking that a pervasive moral idea is universally false seems really odd.

3. 
What kinds of issues is the author talking about? The author is condemning popular morality, but doesn't share his views.

4. 
 His ideas of universal versus relative seem strange. He says that murder is universally wrong, though, but throughout history murder has had varying popular views. 

5. 
Critically think about the popular moral code and come up with your own opinions you can share with a close group of friends.


4
-

1.  
Disobedience is at the center of creativity and is very "American."
Hacks, both elegant and ugly, break the rules.

2. 
Civil liberties lead to innovation and prosperity. Having less imposed means we can figure out what exists today and improve upon it.  

3.  
How do we delineate ugly hacking and groundbreaking hacking, other than use our biases?  

4. 
The last paragraph about rule setting didn't make sense. To whom is he referring with "...be careful what you ask for. You might get it." 

5. 
Dig into what exists to learn and get ideas.
Be wary of artificial restrictions.

5
-  

1.  
Web-based applications are superior to desktop applications because they can be implemented and improved rapidly, taking the customer into account.

2.  
Large companies are frightened of software startups. They can't implement as rapidly and aren't as productive.

3.  
The least technical users are the ones that need web-based software the most. However, they're the slowest to change. How will this be addressed?

4.  
I am not sure I agree with total ownership of different pieces of software by different individuals. I agree that having multiple people write code on top of each other isn't good, but collaboration would probably lead to more elegant solutions.

5.  
Software that is released rapidly contains fewer bugs, and the bugs that are found are smaller and easier to fix.  
To be successful launching a web-based startup, you need to know the technical side.
Rich companies buy expensive solutions because there was more invested by the application company in acquiring them. The software is likely worse.

6
-   

1.  
Wealth is not the same as money. You can create wealth and grow the 'wealth pie.'
In large companies, your effort is measured by the average, so you aren't incentivized to work harder. 

2. 
A single skilled programmer can make hundreds of thousands of dollars of value in a day, while a mediocre programmer can make zero or negative value with the introduction of bugs.  

3. He defines startups as businesses tackling hard technical problems. Are all hard problems techincal? What about a barber that innovates operations or marketing?

4.  
Is a boss always a proxy for the customers? In a big business, bosses do control work, but it seems like they may be less in touch with actual customer needs.

5.  
To gain wealth, put yourself in a position that has both measurement and leverage.
Seek out the harder problems for competitive advantage.
Numbers of users are a proxy for software quality.

7
-  

1.  
Variation in wealth is not a bad thing; it's a sign of innovation. 
Take away individual's ability to keep the wealth they generate and you will stifle innovation.

2.  
We are trapped into thinking wealth should be distributed evenly because of how it was made historically (stolen). Because we were also given money as children, it seems unfair that some should have more than others.

3.  
Is how much someone makes only determined by the market? Are there other factors that influence pay of CEOs, basketball players, etc.?

4.  
His arguement about wealth generated by desirable characteristics makes sense from a free market perspective. What about underpayment for people performing tasks that benefit society as a whole, not individuals as members of the society (research, etc.)? Should everything be determined by the free market?  

5. 
How much someone is worth is dependent on how desirable they are, it's not about what's "fair".
The creation of wealth is the most efficient way to get it (easier than stealing).
Increased wealth is better for everyone, and actually dimishes the perceived gap between the rich and poor (besides $).  
The earner of wealth must be able to retain it to want to create it.

8
-  

1.  
Baysian filtering for spam is more effective than content filtering.

2.  
Spam filtering can be personalized based on the content of the spam and non-spam messages they receive. This is done simply by computing a spam probability from keywords in each.

3.  
I don't have any questions - this seems like a straightforward and elegant solution.

4.  
Spam will stop if people stop responding to it. However, he mentioned that some people are enticed by the content of spam. If these people still respond to spam (15 in 1m), how will spam stop?

5.  
Employing statistics can be very effective in filtering spam. 
Spam is a business with no marginal cost. 

9
-  

1.  
There is such a thing as good design, not subject to personal preference. 
2.  
"Good design is strange". If good design is simple and suggestive, I'm curious how it can also be strange. I think this is the author's personal interpretation of things he likes. 
3.  
Many of the design ideas he gives are high-level. Are there any axioms to good design that are more concrete (beyond simple and symmetrical)? 
If good design is simple, how is it also hard? Shouldn't it be self-evident, particularly with practice?
4.  
This list seems to be stream-of-consciousness opinions about design. Is good design really timeless? Is good design always daring?

5.   
Good design is simple 
Redesign is required to get it right  

10
--

1.  
A quick explanation of and set of opinions on programming languages, open source, and programming culture
2.  
High-level programming languages let us do powerful things with less specific code
3.  
What's the best method for choosing a programming language?
4.  
He said that object-orientation should be an option, not a requirement, of a language. What does this do to tranferability and maintenence of code?
5.  
With high level language, you can transfer it from one machine to another with different compilers

11
--

1.  
A discussion about languages, how their evolution influences their design, and what to be mindful of when designing a language
2.  
Programmers of the future will want to have languages that allow them to do quick prototyping with little effort. They'll want languages that are easier to write, but   can adapt their speed.
3.  
Do we need to bet on the branch that will be working in the next 100 years? Why not use what's applicable now?
4.  
Is it always best to stay on the main branches? Where do cutting-edge languages lie, and how can we figure out how they're going to do without exploring?
5. 
Know the evolution of languages to make good choices about what to use and how to create new langauges
Languages that thrive have the smallest, cleanest cores
OO langauges are not reusable because they're OO, it's because they're bottom-up (libraries for example)


12
--

1.  
Lisp is powerful language and knowing it gives you the freedom to evaluate other languages

2. 
I've never heard of Lisp in use, and he says Lisp is the most powerful language available. Is this still true?  

3.  
The author says a startup should give its competitors as little information as possible, but this seems contradictory to the open source mentality. Many leading startups (37 Signals included) gives quite a bit of information publically in their blog, etc. Where's the balance?  

4.  
Is it really crucial to understand the most powerful language when buidling web apps? Isn't it better to write in a language you're most profiencient in, and one that is best suited for the task at hand (recognizing there might be easier ways to do it in languages you're not as good at)?

5.   
Average performance by a startup means the startup will go out of business
Know the most powerful languages before deciding on what to use for specific applications
Use rare but powerful languages for your competitive advantage
Use job descriptions as a way to evaluate competitors

13
--

1.  







